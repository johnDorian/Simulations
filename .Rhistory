data$hour
na.rm=T
y
y[1,1]+1
names(y)
y[1,1]
y[1,1]+60
y[1,1]+1*60*60
result
data$dates
data$hour
dates
multiple
na.rm
process
data=y
dates
data$hour
data$dates
result
data$minute
result
length(data)
length(data[,1])
names(result)
class(result)
q()
n
b
y
names(y)
y$dates-y$minute*60
y$dates[1]+data$hour*60*60
y$dates[1]+y$hour*60*60
q()
n
b
q()
n
b
q()
n
b
result[1,1]
b[1,1]
b[2,1]
b[65,1]
b[65,1]-59*60
as.numeric(format(b[1,1],"%M"))
q()
n
b
q()
n
b
plot(b)
plot(b,type="l")
b
plot(b,type="l)
"
)
c <- daysAgg(y,mean,7)
c
plot(c)
c <- daysAgg(y,mean,10,T)
c
plot(c)
q()
n
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
data(foo)#
##Format the data using the timeSeries function. #
foo.ts<-timeSeries(foo[,1], "%d\ %m\ %Y  %H:%M"  ,foo[,3])
foo.ts
foo
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
data(foo)
foo[1,1]
library(TSAgg)
?timeSeries
?yearsAgg
?monthsAgg
?dayssAgg
?daysAgg
?hoursAgg
?timeSeries
library(TSAgg)
?timeSeries
?yearsAgg
library(TSAgg)
?yearsAgg
library(TSAgg)
?yearsAgg
?strptime
library(TSAgg)
?yearsAgg
remove.package(TSAgg)
?remove.package(TSAgg)
library(TSAgg)
?yearsAgg
##Load the foo data#
data(foo)#
##Format the data using the timeSeries function. #
foo.ts<-timeSeries(foo[,1],  "%d/%m/%Y   %H:%M",foo[,3])
foo.ts
year.mean <-yearsAgg(foo.ts,mean)#
plot(year.mean)#
##Now plot the min mean and max on one plot.#
year.min <-yearsAgg(foo.ts,min)#
year.max <-yearsAgg(foo.ts,max)#
ymin=min(year.min$data);ymax=max(year.max$data)#
plot(year.mean,ylim=c(ymin,ymax))#
lines(year.min,type="l",lty=3,col="red")#
lines(year.max,type="l",lty=3,col="blue")
library(TSAgg)
?yearsAgg
?TSAgg
help(package=TSAgg)
help.search(package=TSAgg)
help.search("days",package=TSAgg)
help.search("days",package="TSAgg")
data(foo)#
##Format the data using the timeSeries function.#
foo.ts <- timeSeries(foo[,1],"%d/%m/%Y   %H:%M",foo[,3])#
##Aggregate the data into 6 month blocks using mins#
min.month <- monthsAgg(foo.ts,min,6)#
##Aggregate the data into 6 days blocks using max#
max.month <- monthsAgg(foo.ts,max,6)#
##Aggregate the data into 6 days blocks using max#
mean.month <- monthsAgg(foo.ts,mean,6)#
#Create a plot of the results#
ymin=min(min.month$data);ymax=max(max.month$data)#
plot(mean.month,ylim=c(ymin,ymax))#
lines(min.month,type="l",lty=3,col="red")#
lines(max.month,type="l",lty=3,col="blue")
data(foo)#
##Format the data using the timeSeries function.#
foo.ts <- timeSeries(foo[,1],"%d/%m/%Y   %H:%M",foo[,3])#
##Aggregate the data into 6 month blocks using mins#
min.month <- monthsAgg(foo.ts,min,8)#
##Aggregate the data into 6 days blocks using max#
max.month <- monthsAgg(foo.ts,max,8)#
##Aggregate the data into 6 days blocks using max#
mean.month <- monthsAgg(foo.ts,mean,8)#
#Create a plot of the results#
ymin=min(min.month$data);ymax=max(max.month$data)#
plot(mean.month,ylim=c(ymin,ymax))#
lines(min.month,type="l",lty=3,col="red")#
lines(max.month,type="l",lty=3,col="blue")
data(foo)#
##Format the data using the timeSeries function.#
foo.ts <- timeSeries(foo[,1],"%d/%m/%Y   %H:%M",foo[,3])#
##Aggregate the data into 6 month blocks using mins#
min.month <- monthsAgg(foo.ts,min,24)#
##Aggregate the data into 6 days blocks using max#
max.month <- monthsAgg(foo.ts,max,24)#
##Aggregate the data into 6 days blocks using max#
mean.month <- monthsAgg(foo.ts,mean,24)#
#Create a plot of the results#
ymin=min(min.month$data);ymax=max(max.month$data)#
plot(mean.month,ylim=c(ymin,ymax))#
lines(min.month,type="l",lty=3,col="red")#
lines(max.month,type="l",lty=3,col="blue")
mean.month
monthsAgg(foo.ts,mean,13)
d=seq(1:20)
d
d-d%%3
(d-d%%3)%%12
d=seq(1:30)
d-d%%3
(d-d%%3)%%24
(d-d%%1)%%24
data(foo)
library(foo)
library(TSAgg)
foo[1]
foo[1,1]
?monthsAgg
foo.ts <- timeSeries(foo[,1],"%d/%m/%Y   %H:%M",foo[,3])
fo.ts[1,1]
foo.ts[1,1]
foo.ts[1,2]
foo.ts[2,1]
months=foo.ts$month
months
months=0
months
months=foo.ts$month
months=NA
months
cummulative
?cummulative
??cummulative
cumsum(1:10)
cumsum(foo.ts$month)
foo.ts$month<-cumsum(foo.ts$month)
foo.ts$month
(data$month-data$month%%4)%%12
(foo.ts$month-foo.ts$month%%4)%%12
(foo.ts$month-foo.ts$month%%4)%%13
(foo.ts$month-foo.ts$month%%4)
(foo.ts$month-foo.ts$month%%4)%%12
data$date
foo.ts$date
foo.ts[1]-foo.ts[1381]
foo.ts$date[1]-foo.ts$date[1381]
foo.ts$date[1381]-foo.ts$date[1]
(foo.ts$month-foo.ts$month%%4)/12
(foo.ts$month-foo.ts$month%%4)%%12
(foo.ts$month-foo.ts$month%%1)%%12
foo.ts <- timeSeries(foo[,1],"%d/%m/%Y   %H:%M",foo[,3])
daysAgg(foo.ts,mean,400)
hoursAgg(foo.ts,mean,400)
yearsAgg(foo.ts,mean)
yearsAgg(foo.ts,mean,10)
yearsAgg(foo.ts,mean,20)
yearsAgg(foo.ts,mean,3)
win.graph = function(){if(.Platform$OS=='unix') x11() else win.graph()=x11()}
win.graph = function(){if(.Platform$OS=='unix') x11() else win.graph()=x11()}
setwd("~/Documents/code/Simulations/")
data<-read.csv("TP_flow.csv", header=TRUE)
library(gstat);library(geoR);library(MASS);library(TeachingDemos);library(moments)
back.up <- data
data <- data[,-c(1,2)]
names(data) <- c("X","Y","TP","FLOW")
data$TP <- data$TP+0.01
data$FLOW <- data$FLOW+0.01
TP.lambda <- boxcox.fit(data$TP)
FLOW.lambda <- boxcox.fit(data$FLOW)
win.graph()#
par(mfrow=c(2,2))#
hist(log(data$TP),xlab="skewness = 0.96",main="Log Transformation of TP")#
hist(log(data$FLOW),xlab="skewness = -0.45",main="Log Transformation of Flow")#
hist(bct(data$TP,TP.lambda$lambda),xlab="skewness = 0.067, lambda = -0.42",main="Boxcox Trans. of TP")#
hist(bct((data$FLOW),FLOW.lambda$lambda),xlab="skewness = 0.016, lambda = -0.088",main="Boxcox Trans. of TP")
data.log <- data
data.log$TP <- log(data$TP)
data.log$FLOW <- log(data$FLOW)
data.bc <- data
data.bc$TP <- bct(data$TP,TP.lambda$lambda)
data.bc$FLOW <- bct(data$FLOW,FLOW.lambda$lambda)
qual.tp.log<-as.geodata(data.1,coords.col=1:2,data.col=3)#
qual.flow.log<-as.geodata(data.1,coords.col=1:2,data.col=4)#
qual.tp.bc<-as.geodata(data.2,coords.col=1:2,data.col=3)#
qual.flow.bc<-as.geodata(data.2,coords.col=1:2,data.col=4)
#
qual.tp.log<-as.geodata(data.log,coords.col=1:2,data.col=3)#
qual.flow.log<-as.geodata(data.log,coords.col=1:2,data.col=4)#
qual.tp.bc<-as.geodata(data.bc,coords.col=1:2,data.col=3)#
qual.flow.bc<-as.geodata(data.bc,coords.col=1:2,data.col=4)
log.tp.likfit <- likfit(qual.tp.log,ini=c(0.5,0.5),lik.method="REML")
log.flow.likfit <- likfit(qual.flow.log,ini=c(0.5,0.5),lik.method="REML")
bc.tp.likfit <- likfit(qual.tp.bc,ini=c(0.5,0.5),lik.method="REML")
bc.flow.likfit <- likfit(qual.flow.bc,ini=c(0.5,0.5),lik.method="REML")
summary(log.tp.likfit)#
summary(log.tp.likfit)#
summary(bc.flow.likfit)#
summary(bc.flow.likfit)
log.tp.psill <- summary(log.tp.likfit)$spatial.component[[2]][1]#
log.flow.psill <- summary(log.flow.likfit)$spatial.component[[2]][1]#
bc.tp.psill <- summary(bc.tp.likfit)$spatial.component[[2]][1]#
bc.flow.psill <- summary(bc.flow.likfit)$spatial.component[[2]][1]
## Rip the nuggets from the likfits#
log.tp.nug <- summary(log.tp.likfit)$nugget.component[[2]]#
log.flow.nug <- summary(log.flow.likfit)$nugget.component[[2]]#
bc.tp.nug <- summary(bc.tp.likfit)$nugget.component[[2]]#
bc.flow.nug <- summary(bc.flow.likfit)$nugget.component[[2]]#
#
#
## Rip the range values from the likfits#
log.tp.range <- summary(log.tp.likfit)$practicalRange#
log.flow.range <- summary(log.flow.likfit)$practicalRange#
bc.tp.range <- summary(bc.tp.likfit)$practicalRange#
bc.flow.range <- summary(bc.flow.likfit)$practicalRang
## Use the above results of the likfit to run the lmcr code.#
log.spdf <- SpatialPointsDataFrame(data.log[,1:2],data.log)#
bc.spdf <- SpatialPointsDataFrame(data.bc[,1:2],data.bc)#
#Calculate the experimental auto-semivariogram#
log.tp.vgm <- variogram(log.spdf$TP~1,log.spdf,cutoff=200,width=200/20)#
log.flow.vgm <- variogram(log.spdf$FLOW~1,log.spdf,cutoff=200,width=200/20)#
bc.tp.vgm <- variogram(bc.spdf$TP~1,bc.spdf,cutoff=200,width=200/20)#
bc.flow.vgm <- variogram(bc.spdf$FLOW~1,bc.spdf,cutoff=200,width=200/20)
win.graph()#
par(mfrow=c(2,2))#
plot(log.tp.vgm[,2],log.tp.vgm[,3])#
plot(log.flow.vgm[,2],log.flow.vgm[,3])#
plot(bc.tp.vgm[,2],bc.tp.vgm[,3])#
plot(bc.flow.vgm[,2],bc.flow.vgm[,3])
log.tp.fit <- fit.variogram(log.tp.vgm,model=vgm(log.tp.psill,"Sph",log.tp.range,log.tp.nug))#
log.flow.fit <- fit.variogram(log.flow.vgm,model=vgm(log.flow.psill,"Sph",log.flow.range,log.flow.nug))#
bc.tp.fit <- fit.variogram(bc.tp.vgm,model=vgm(bc.tp.psill,"Sph",bc.flow.range,bc.tp.nug))#
bc.flow.fit <- fit.variogram(bc.flow.vgm,model=vgm(bc.flow.psill,"Sph",bc.flow.range,bc.flow.nug))
plot(log.tp.vgm,log.tp.fit)
plot(log.flow.vgm,log.flow.fit)
plot(bc.tp.vgm,bc.tp.fit)
plot(bc.flow.vgm,bc.flow.fit)
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)
g.log = gstat(g.log, "FLOW", log.spdf$FLOW ~ 1, log.spdf)
v.log = variogram(g.log,cutoff=200,width=200/20)
plot(v.log)
g.log = gstat(g.log, model = vgm(1, "Sph", 3000, 1), fill.all = TRUE)
g.log.fit = fit.lmc(v.log, g.log)
plot(v.log, g.log.fit)
g.bc = gstat(NULL, "TP", bc.spdf$TP ~ 1, bc.spdf)
g.bc = gstat(g.log, "FLOW", bc.spdf$FLOW ~ 1, bc.spdf)
g.bc = gstat(NULL, "TP", bc.spdf$TP ~ 1, bc.spdf)
g.bc = gstat(g.bc, "FLOW", bc.spdf$FLOW ~ 1, bc.spdf)
v.bc = variogram(g.bc,cutoff=200,width=200/20)
plot(v.bc)
g.bc = gstat(g.bc, model = vgm(1, "Sph", 3000, 1), fill.all = TRUE)
g.bc.fit = fit.lmc(v.bc, g.bc)
win.graph()
plot(v.bc, g.bc.fit)
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)
remove(g.log)
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)#
#Somehow links b1 with b0 so it knows cross-semivariograms are needed#
g.log = gstat(g.log, "FLOW", log.spdf$FLOW ~ 1, log.spdf)#
#Calculates auto and cross-semivariograms#
v.log = variogram(g.log,cutoff=200,width=200/20)#
plot(v.log)#
#Defines form of LMCR - range, variogram model#
g.log = gstat(g.log, model = vgm(1, "Sph", 3000, 1), fill.all = TRUE)#
#Fits LMCR model#
g.log.fit = fit.lmc(v.log, g.log)#
#
plot(v.log, g.log.fit)
g.bc = gstat(NULL, "TP", bc.spdf$TP ~ 1, bc.spdf)#
#Somehow links b1 with b0 so it knows cross-semivariograms are needed#
g.bc = gstat(g.bc, "FLOW", bc.spdf$FLOW ~ 1, bc.spdf)#
#Calculates auto and cross-semivariograms#
v.bc = variogram(g.bc,cutoff=200,width=200/20)#
plot(v.bc)#
#Defines form of LMCR - range, variogram model#
g.bc = gstat(g.bc, model = vgm(1, "Sph", 3000, 1), fill.all = TRUE)#
#Fits LMCR model#
g.bc.fit = fit.lmc(v.bc, g.bc)#
win.graph()#
plot(v.bc, g.bc.fit)
#
#Creates a dataset for auto-semivariogram estimation#
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)#
#Somehow links b1 with b0 so it knows cross-semivariograms are needed#
g.log = gstat(g.log, "FLOW", log.spdf$FLOW ~ 1, log.spdf)#
#Calculates auto and cross-semivariograms#
v.log = variogram(g.log,cutoff=200,width=200/20)#
plot(v.log)#
#Defines form of LMCR - range, variogram model#
g.log = gstat(g.log, model = vgm(1, "Sph", 3000, 1), fill.all = TRUE)#
#Fits LMCR model#
g.log.fit = fit.lmc(v.log, g.log)#
#
plot(v.log, g.log.fit)
win.graph()
plot(v.bc, g.bc.fit)
?yearsAgg
