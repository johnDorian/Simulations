	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
icpo
covar
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.range=TRUE,fit.method=3)
rm(fit)
rm(g)
rm(v)
spdf <- SpatialPointsDataFrame(data[,1:2],data)#
#
### STEP 1. Create A gstat object with TP and flow.#
g = gstat(NULL, "TP", spdf$TP ~ 1, spdf,,maxdist=200)#
g = gstat(g, "FLOW", spdf$FLOW ~ 1, spdf,maxdist=200)#
#
### STEP 2. Create intial values for the models.#
#Create variogarms for plotting.#
v = variogram(g,cutoff=200,width=200/20)#
####	Need to re-organise for the lmcr function.#
bins<-as.numeric(summary(v$id))[1]#
cross<-split(v,v$id)[[1]]$gamma#
auto.1<-split(v,v$id)[[2]]$gamma#
auto.2<-split(v,v$id)[[3]]$gamma#
dist<-split(v,v$id)[[1]]$dist#
pairs<-split(v,v$id)[[1]]$np#
semvar=data.frame(dist,auto.1,cross,auto.2,pairs)#
#
#lmcr<-function(semvar,nolags,nvar,wgt,icvp,cparf,modtyp,covar,maxdist,guessa,lock)#
#need to know wgt,cparf,covar,guessa,lock#
#
#
#Plot the cross covariogram and get some initial values for it.#
plot(v,g)#
#The cross covariance models using initial values, these will change.#
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Sph",48,0.2),fill.all=TRUE)#
#
### STEP 3. Find the range of each covariogram using fit.lmc#
##Use fit.lmc() function to find the ranges for each covariogram.#
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.range=TRUE,fit.method=3)
fit
spdf <- SpatialPointsDataFrame(data[,1:2],data)#
#
### STEP 1. Create A gstat object with TP and flow.#
g = gstat(NULL, "TP", spdf$TP ~ 1, spdf,,maxdist=200)#
g = gstat(g, "FLOW", spdf$FLOW ~ 1, spdf,maxdist=200)#
#
### STEP 2. Create intial values for the models.#
#Create variogarms for plotting.#
v = variogram(g,cutoff=200,width=200/20)#
####	Need to re-organise for the lmcr function.#
bins<-as.numeric(summary(v$id))[1]#
cross<-split(v,v$id)[[1]]$gamma#
auto.1<-split(v,v$id)[[2]]$gamma#
auto.2<-split(v,v$id)[[3]]$gamma#
dist<-split(v,v$id)[[1]]$dist#
pairs<-split(v,v$id)[[1]]$np#
semvar=data.frame(dist,auto.1,cross,auto.2,pairs)#
#
#lmcr<-function(semvar,nolags,nvar,wgt,icvp,cparf,modtyp,covar,maxdist,guessa,lock)#
#need to know wgt,cparf,covar,guessa,lock#
#
#
#Plot the cross covariogram and get some initial values for it.#
plot(v,g)#
#The cross covariance models using initial values, these will change.#
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Sph",48,0.2),fill.all=TRUE)#
#
### STEP 3. Find the range of each covariogram using fit.lmc#
##Use fit.lmc() function to find the ranges for each covariogram.#
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.sills=TRUE,fit.method=3)
fit=fit.lmc(v,g,fit.fit.lmc=TRUE,fit.method=3)
fit=fit.lmc(v,g,fit.fit.lmc=FALSE,fit.method=3)
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.method=3)
fit=fit.lmc(v,g,fit.lmc=TRUE)
fit
fit=fit.lmc(v,g,fit.lmc=FALSE)
fit
covar<-covStructure(fit)#
eigen(covar)
data<-read.csv("TP_flow.csv", header=TRUE)#
## Load the nessacry libraries. A couple for variograms, and some for the boxcox transformations.#
library(gstat);library(geoR);library(MASS);library(TeachingDemos);library(moments)#
## Clean up the dataset - create a back.up of the data#
back.up <- data#
data <- data[,-c(1,2)]#
names(data) <- c("X","Y","TP","FLOW")#
## Add arbituary value to the data, so we can transform the data.#
data$TP <- log(data$TP+0.01)#
data$FLOW <- log(data$FLOW+0.01)#
#
##Create gstat objects of the data#
spdf <- SpatialPointsDataFrame(data[,1:2],data)
g = gstat(NULL, "TP", spdf$TP ~ 1, spdf,,maxdist=200)#
g = gstat(g, "FLOW", spdf$FLOW ~ 1, spdf,maxdist=200)#
#
### STEP 2. Create intial values for the models.#
#Create variogarms for plotting.#
v = variogram(g,cutoff=200,width=200/20)#
####	Need to re-organise for the lmcr function.#
bins<-as.numeric(summary(v$id))[1]#
cross<-split(v,v$id)[[1]]$gamma#
auto.1<-split(v,v$id)[[2]]$gamma#
auto.2<-split(v,v$id)[[3]]$gamma#
dist<-split(v,v$id)[[1]]$dist#
pairs<-split(v,v$id)[[1]]$np#
semvar=data.frame(dist,auto.1,cross,auto.2,pairs)
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Sph",48,0.2),fill.all=TRUE)#
#
### STEP 3. Find the range of each covariogram using fit.lmc#
##Use fit.lmc() function to find the ranges for each covariogram.#
fit=fit.lmc(v,g,fit.fit.lmc=TRUE,fit.range=TRUE,fit.method=3)#
covar<-covStructure(fit)#
eigen(covar)
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.range=TRUE,fit.method=3)
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.ranges=TRUE,fit.method=3)
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.ranges=FALSE,fit.method=3)
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.ranges=FALSE)
fit
covar<-covStructure(fit)#
eigen(covar)
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Exp",48,0.2),fill.all=TRUE)
g
fit=fit.lmc(v,g,fit.lmc=TRUE,fit.range=TRUE)
fit
covar<-covStructure(fit)#
eigen(covar)
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
fit=fit.lmc(v,g,fit.lmc=TRUE)
fit
covar<-covStructure(fit)#
eigen(covar)
det(covar)
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
fit=fit.lmc(v,g,fit.lmc=FALSE)
fit
fit=fit.lmc(v,g,fit.lmc=FALSE,fit.range=TRUE)
fit
fit=fit.lmc(v,g,fit.lmc=FALSE,fit.sills=TRUE)
fit
fit=fit.lmc(v,g,fit.lmc=FALSE,fit.range=TRUE)
covar<-covStructure(fit)#
eigen(covar)
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
c
covar
nstr
modtyp
det(covar)
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Mat",48,0.2),fill.all=TRUE)
g
fit=fit.lmc(v,g,fit.lmc=FALSE)
covar<-covStructure(fit)
covar
eigen(covar)
qual.tp.log<-as.geodata(data,coords.col=1:2,data.col=3)#
qual.flow.log<-as.geodata(data,coords.col=1:2,data.col=4)
log.tp.likfit <- likfit(qual.tp.log,ini=c(0.5,0.5),lik.method="REML") #
log.flow.likfit <- likfit(qual.flow.log,ini=c(0.5,0.5),lik.method="REML")
log.tp.psill <- summary(log.tp.likfit)$spatial.component[[2]][1]#
log.flow.psill <- summary(log.flow.likfit)$spatial.component[[2]][1]
log.tp.nug <- summary(log.tp.likfit)$nugget.component[[2]]#
log.flow.nug <- summary(log.flow.likfit)$nugget.component[[2]]
log.tp.range <- summary(log.tp.likfit)$practicalRange#
log.flow.range <- summary(log.flow.likfit)$practicalRange
v.log.cloud = variogram(g.log,cloud=TRUE)
log.spdf <- SpatialPointsDataFrame(data.log[,1:2],data.log)
log.spdf <- SpatialPointsDataFrame(data[,1:2],data)
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)#
g.bc = gstat(NULL, "TP", bc.spdf$TP ~ 1, bc.spdf)
g.log = gstat(g.log, "FLOW", log.spdf$FLOW ~ 1, log.spdf)
v.log = variogram(g.log,cutoff=200,width=200/20)
v.log.cloud = variogram(g.log,cloud=TRUE)
dummy.geodata<-as.geodata(data.log,coords.col=1:2,data.col=3)
dummy.geodata<-as.geodata(data,coords.col=1:2,data.col=3)
dummy.var1<-variog(qual.tp.log,estimator.type="classical",option=c("cloud"))
dummy.var1$u<-v.log.cloud$dist#
dummy.var1$v<-v.log.cloud$gamma
log<-variofit(dummy.var1,ini=c(0.5,0.5),cov.model="spherical", fix.nugget=F,max.dist=200,minimisation.function="nls")
log
log.spdf <- SpatialPointsDataFrame(data[,1:2],data)
v.log = variogram(g,cutoff=200,width=200/20)
g.log = gstat(NULL, "TP", log.spdf$TP ~ 1, log.spdf)#
g.log = gstat(g.log, "FLOW", log.spdf$FLOW ~ 1, log.spdf)
g.log = gstat(g.log,id="TP",model=vgm(log.tp.psill,"Sph",log.tp.range,log.tp.nug))#
g.log = gstat(g.log,id="FLOW",model=vgm(log.flow.psill,"Sph",log.flow.range,log.flow.nug))#
g.log = gstat(g.log,id=c("TP","FLOW"),model=vgm(summary(log)$spatial.component[[1]][1], "Sph", log$practicalRange, log$nugget))
g.log
covar<-covStructure(g.log)
cvar
covar
covStructure <- function(object){#
auto1 <- object$model[1][[1]][[2]][1]#
auto2 <- object$model[3][[1]][[2]][1]#
cross <- object$model[2][[1]][[2]][1]#
d <- matrix(c(auto1,cross,cross,auto2),c(2,2))#
return(d)#
}
covar<-covStructure(g.log)
covar
covStructure <- function(object){#
auto1 <- object$model[1][[1]][[2]][1]#
auto2 <- object$model[2][[1]][[2]][1]#
cross <- object$model[3][[1]][[2]][1]#
d <- matrix(c(auto1,cross,cross,auto2),c(2,2))#
return(d)#
}
covar<-covStructure(g.log)
covar
fit
g.log
v.log
v<-v.log
bins<-as.numeric(summary(v$id))[1]#
cross<-split(v,v$id)[[1]]$gamma#
auto.1<-split(v,v$id)[[2]]$gamma#
auto.2<-split(v,v$id)[[3]]$gamma#
dist<-split(v,v$id)[[1]]$dist#
pairs<-split(v,v$id)[[1]]$np#
semvar=data.frame(dist,auto.1,cross,auto.2,pairs)
semvar
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
icpo
	CM=array(NA,c(2,2))#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			CM[ir,ic]=c[istr+1,ir,ic]#
			CM[ic,ir]=c[istr+1,ic,ir]#
		}#
	}
CM
istr
eval<-eigen(CM)$values
eval
rmin=10000.0#
	for(ix in 1:nvar){#
		if(rmin>=eval[ix]) rmin=eval[ix]#
	}
rmin
if(rmin<=-0.000001)icpo=-1 else icpo=1#
	return(icpo)#
}
det(covar)
c
covar
check<-function(c,nvar,istr){#
	CM=array(NA,c(2,2))#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			CM[ir,ic]=c[istr+1,ir,ic]#
			CM[ic,ir]=c[istr+1,ic,ir]#
		}#
	}#
#
#
### Get the eigenvalues of the matrix cm#
	eval<-eigen(CM)$values#
	#
	rmin=10000.0#
	for(ix in 1:nvar){#
		if(rmin>=eval[ix]) rmin=eval[ix]#
	}#
	if(rmin>=0.000001)icpo=-1 else icpo=1#
	return(icpo)#
}
	results<-list(WSSGuessedParameter=0,initialTemperature=0,coolingParameter=0,#
	numberTrialMarkovChain=0,numberMarkovChainReturningNoChange=0,#
	weightingOption=0,finalWSS=0,variableAIC=0,effectiveRange1=0,#
	effectiveRange2=0,effectiveRange1stStructure=0,effectiveRange2ndStructure=0,#
	solutionAfter=0,structure=0,distanceParameter=0,ir=0,ic=0,c=0,other.ics=0,#
	other.f=0,other.pacc=0)#
#
### Final values to delcare - checked off values...#
	nvar=2#
	sd=matrix(ncol=2)#
	dataf=array(0,c(nvar,nvar,3,500))#
###Other variables - still unsure about...#
	am=matrix(ncol=2)#
	c=array(NA,c(3,nvar,nvar))#
	dm=array(NA,c(3,nvar,nvar))#
	temp=NA#
###declaration finished...#
#
### first loop #
	index=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			index=index+1#
			for(ix in 1:nolags){#
				dataf[ir,ic,1,ix]=semvar[ix,1]#
		#
				if(index==1)dataf[ir,ic,2,ix]=semvar[ix,2] #
					else#
				if(index==2)dataf[ir,ic,2,ix]=semvar[ix,3]#
					else#
				if(index==3)dataf[ir,ic,2,ix]=semvar[ix,4]#
				dataf[ir,ic,2,ix]=semvar[ix,5]#
			#
			}#
		}#
	}#
#
	nlags=nolags#
	#
#
### Standard deviations of each variable.#
	sd[1]=sqrt(covar[1,1])#
	sd[2]=sqrt(covar[2,2])#
#
### Adjust 'AMAX' if necessary.#
	amax=maxdist#
	if(modtyp==1||modtyp==3||modtyp==4)amax=amax/3#
	amax=amax*1.5#
#
#
#
###	Enter initial guesses of the variogram parameters.#
#
###	Distance parameters.#
	a=guessa#
#
###	Nugget of the first variable's auto-variogram.#
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
nolags=20
guessa=48
	results<-list(WSSGuessedParameter=0,initialTemperature=0,coolingParameter=0,#
	numberTrialMarkovChain=0,numberMarkovChainReturningNoChange=0,#
	weightingOption=0,finalWSS=0,variableAIC=0,effectiveRange1=0,#
	effectiveRange2=0,effectiveRange1stStructure=0,effectiveRange2ndStructure=0,#
	solutionAfter=0,structure=0,distanceParameter=0,ir=0,ic=0,c=0,other.ics=0,#
	other.f=0,other.pacc=0)#
#
### Final values to delcare - checked off values...#
	nvar=2#
	sd=matrix(ncol=2)#
	dataf=array(0,c(nvar,nvar,3,500))#
###Other variables - still unsure about...#
	am=matrix(ncol=2)#
	c=array(NA,c(3,nvar,nvar))#
	dm=array(NA,c(3,nvar,nvar))#
	temp=NA#
###declaration finished...#
#
### first loop #
	index=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			index=index+1#
			for(ix in 1:nolags){#
				dataf[ir,ic,1,ix]=semvar[ix,1]#
		#
				if(index==1)dataf[ir,ic,2,ix]=semvar[ix,2] #
					else#
				if(index==2)dataf[ir,ic,2,ix]=semvar[ix,3]#
					else#
				if(index==3)dataf[ir,ic,2,ix]=semvar[ix,4]#
				dataf[ir,ic,2,ix]=semvar[ix,5]#
			#
			}#
		}#
	}#
#
	nlags=nolags#
	#
#
### Standard deviations of each variable.#
	sd[1]=sqrt(covar[1,1])#
	sd[2]=sqrt(covar[2,2])#
#
### Adjust 'AMAX' if necessary.#
	amax=maxdist#
	if(modtyp==1||modtyp==3||modtyp==4)amax=amax/3#
	amax=amax*1.5#
#
#
#
###	Enter initial guesses of the variogram parameters.#
#
###	Distance parameters.#
	a=guessa#
#
###	Nugget of the first variable's auto-variogram.#
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
maxdist=200
	results<-list(WSSGuessedParameter=0,initialTemperature=0,coolingParameter=0,#
	numberTrialMarkovChain=0,numberMarkovChainReturningNoChange=0,#
	weightingOption=0,finalWSS=0,variableAIC=0,effectiveRange1=0,#
	effectiveRange2=0,effectiveRange1stStructure=0,effectiveRange2ndStructure=0,#
	solutionAfter=0,structure=0,distanceParameter=0,ir=0,ic=0,c=0,other.ics=0,#
	other.f=0,other.pacc=0)#
#
### Final values to delcare - checked off values...#
	nvar=2#
	sd=matrix(ncol=2)#
	dataf=array(0,c(nvar,nvar,3,500))#
###Other variables - still unsure about...#
	am=matrix(ncol=2)#
	c=array(NA,c(3,nvar,nvar))#
	dm=array(NA,c(3,nvar,nvar))#
	temp=NA#
###declaration finished...#
#
### first loop #
	index=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			index=index+1#
			for(ix in 1:nolags){#
				dataf[ir,ic,1,ix]=semvar[ix,1]#
		#
				if(index==1)dataf[ir,ic,2,ix]=semvar[ix,2] #
					else#
				if(index==2)dataf[ir,ic,2,ix]=semvar[ix,3]#
					else#
				if(index==3)dataf[ir,ic,2,ix]=semvar[ix,4]#
				dataf[ir,ic,2,ix]=semvar[ix,5]#
			#
			}#
		}#
	}#
#
	nlags=nolags#
	#
#
### Standard deviations of each variable.#
	sd[1]=sqrt(covar[1,1])#
	sd[2]=sqrt(covar[2,2])#
#
### Adjust 'AMAX' if necessary.#
	amax=maxdist#
	if(modtyp==1||modtyp==3||modtyp==4)amax=amax/3#
	amax=amax*1.5#
#
#
#
###	Enter initial guesses of the variogram parameters.#
#
###	Distance parameters.#
	a=guessa#
#
###	Nugget of the first variable's auto-variogram.#
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
covar
covStructure <- function(object){#
auto1 <- object$model[1][[1]][[2]][1]#
auto2 <- object$model[3][[1]][[2]][1]#
cross <- object$model[2][[1]][[2]][1]#
d <- matrix(c(auto1,cross,cross,auto2),c(2,2))#
return(d)#
}#
#
###Now we can actually start with the script.#
#
## Set the working directory.#
setwd("~/Documents/code/Simulations/")
data<-read.csv("TP_flow.csv", header=TRUE)#
## Load the nessacry libraries. A couple for variograms, and some for the boxcox transformations.#
library(gstat);library(geoR);library(MASS);library(TeachingDemos);library(moments)#
## Clean up the dataset - create a back.up of the data#
back.up <- data#
data <- data[,-c(1,2)]#
names(data) <- c("X","Y","TP","FLOW")#
## Add arbituary value to the data, so we can transform the data.#
data$TP <- log(data$TP+0.01)#
data$FLOW <- log(data$FLOW+0.01)#
#
##Create gstat objects of the data#
spdf <- SpatialPointsDataFrame(data[,1:2],data)#
#
### STEP 1. Create A gstat object with TP and flow.#
g = gstat(NULL, "TP", spdf$TP ~ 1, spdf,,maxdist=200)#
g = gstat(g, "FLOW", spdf$FLOW ~ 1, spdf,maxdist=200)
v = variogram(g,cutoff=200,width=200/20)#
####	Need to re-organise for the lmcr function.#
bins<-as.numeric(summary(v$id))[1]#
cross<-split(v,v$id)[[1]]$gamma#
auto.1<-split(v,v$id)[[2]]$gamma#
auto.2<-split(v,v$id)[[3]]$gamma#
dist<-split(v,v$id)[[1]]$dist#
pairs<-split(v,v$id)[[1]]$np#
semvar=data.frame(dist,auto.1,cross,auto.2,pairs)
g
g = gstat(g,id=c("TP","FLOW"),model=vgm(0.5,"Mat",48,0.2),fill.all=TRUE)
fit=fit.lmc(v,g,fit.lmc=FALSE)
fit
fit$model
g$model
covar<-covStructure(g.log)
covar
covar<-covStructure(fit)
covar
	results<-list(WSSGuessedParameter=0,initialTemperature=0,coolingParameter=0,#
	numberTrialMarkovChain=0,numberMarkovChainReturningNoChange=0,#
	weightingOption=0,finalWSS=0,variableAIC=0,effectiveRange1=0,#
	effectiveRange2=0,effectiveRange1stStructure=0,effectiveRange2ndStructure=0,#
	solutionAfter=0,structure=0,distanceParameter=0,ir=0,ic=0,c=0,other.ics=0,#
	other.f=0,other.pacc=0)#
#
### Final values to delcare - checked off values...#
	nvar=2#
	sd=matrix(ncol=2)#
	dataf=array(0,c(nvar,nvar,3,500))#
###Other variables - still unsure about...#
	am=matrix(ncol=2)#
	c=array(NA,c(3,nvar,nvar))#
	dm=array(NA,c(3,nvar,nvar))#
	temp=NA#
###declaration finished...#
#
### first loop #
	index=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			index=index+1#
			for(ix in 1:nolags){#
				dataf[ir,ic,1,ix]=semvar[ix,1]#
		#
				if(index==1)dataf[ir,ic,2,ix]=semvar[ix,2] #
					else#
				if(index==2)dataf[ir,ic,2,ix]=semvar[ix,3]#
					else#
				if(index==3)dataf[ir,ic,2,ix]=semvar[ix,4]#
				dataf[ir,ic,2,ix]=semvar[ix,5]#
			#
			}#
		}#
	}#
#
	nlags=nolags#
	#
#
### Standard deviations of each variable.#
	sd[1]=sqrt(covar[1,1])#
	sd[2]=sqrt(covar[2,2])#
#
### Adjust 'AMAX' if necessary.#
	amax=maxdist#
	if(modtyp==1||modtyp==3||modtyp==4)amax=amax/3#
	amax=amax*1.5#
#
#
#
###	Enter initial guesses of the variogram parameters.#
#
###	Distance parameters.#
	a=guessa#
#
###	Nugget of the first variable's auto-variogram.#
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
	for(i in 1:nstr){#
		if(modtyp==1||modtyp==4){#
			amin=dataf[1,1,1,2]/3#
			if(a[i]<33)am[i]=1 else am[i]=2#
		}else#
		if(modtyp==2||modtyp==5){#
			amin=dataf[1,1,1,2]#
			if(a[i]<100)am[i]=1 else am[i]=2#
		}#
	}
a
a[i]
i
guessa=cbind(2,2)
guessa
guessa=cbind(48,48)
guessa
	results<-list(WSSGuessedParameter=0,initialTemperature=0,coolingParameter=0,#
	numberTrialMarkovChain=0,numberMarkovChainReturningNoChange=0,#
	weightingOption=0,finalWSS=0,variableAIC=0,effectiveRange1=0,#
	effectiveRange2=0,effectiveRange1stStructure=0,effectiveRange2ndStructure=0,#
	solutionAfter=0,structure=0,distanceParameter=0,ir=0,ic=0,c=0,other.ics=0,#
	other.f=0,other.pacc=0)#
#
### Final values to delcare - checked off values...#
	nvar=2#
	sd=matrix(ncol=2)#
	dataf=array(0,c(nvar,nvar,3,500))#
###Other variables - still unsure about...#
	am=matrix(ncol=2)#
	c=array(NA,c(3,nvar,nvar))#
	dm=array(NA,c(3,nvar,nvar))#
	temp=NA#
###declaration finished...#
#
### first loop #
	index=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			index=index+1#
			for(ix in 1:nolags){#
				dataf[ir,ic,1,ix]=semvar[ix,1]#
		#
				if(index==1)dataf[ir,ic,2,ix]=semvar[ix,2] #
					else#
				if(index==2)dataf[ir,ic,2,ix]=semvar[ix,3]#
					else#
				if(index==3)dataf[ir,ic,2,ix]=semvar[ix,4]#
				dataf[ir,ic,2,ix]=semvar[ix,5]#
			#
			}#
		}#
	}#
#
	nlags=nolags#
	#
#
### Standard deviations of each variable.#
	sd[1]=sqrt(covar[1,1])#
	sd[2]=sqrt(covar[2,2])#
#
### Adjust 'AMAX' if necessary.#
	amax=maxdist#
	if(modtyp==1||modtyp==3||modtyp==4)amax=amax/3#
	amax=amax*1.5#
#
#
#
###	Enter initial guesses of the variogram parameters.#
#
###	Distance parameters.#
	a=guessa#
#
###	Nugget of the first variable's auto-variogram.#
	c[1,1,1]=covar[1,1]*0.25#
#
###	Nugget of the second variable's auto-variogram.#
	c[1,2,2]=covar[2,2]*0.25#
#
###	Nugget of the cross-variogram.#
	c[1,1,2]=covar[1,2]*0.05#
#
	if(c[1,1,1]==0||c[1,2,2]==0)c[1,1,2]=0#
#
	c[1,2,1]=c[1,1,2]#
#
#
	if(modtyp<4){#
		if(modtyp==3)nstr=2 else nstr=1#
### C1 of the first variable's auto-variogram.		#
		c[2,1,1]=covar[1,1]*0.75#
### C1 of the second variable's auto-variogram#
		c[2,2,2]=covar[2,2]*0.75#
### C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.25#
		#
		if(c[2,1,1]==0||c[2,1,1]==0)c[2,1,2]=0#
		c[2,2,1]=c[2,1,2]#
	}	#
#
#
#
	if(modtyp>=4){#
		nstr=2#
### C1 of the first variable's auto-variogram.#
		c[2,1,1]=covar[1,1]*0.375#
#
###		C1 of the second variable's auto-variogram.#
		c[2,2,2]=covar[2,2]*0.375#
#
###		C1 of the cross-variogram#
		c[2,1,2]=covar[1,2]*0.1#
#
		if(c[2,1,1]==0||c[2,2,2]==0)c[2,1,2]=0#
		#
		c[2,2,1]=c[1,1,2]#
#
#
###		C2 of the first variable's auto-variogram.#
		c[3,1,1]=covar[1,1]*0.375#
#
###		C2 of the second variable's auto-variogram.#
		c[3,2,2]=covar[2,2]*0.375#
#
###		C2 of the cross-variogram.#
		c[3,1,2]=covar[1,2]*0.25#
#
		if(c[3,1,1]==0||c[3,2,2]==0)c[3,1,2]=0#
		c[3,2,1]=c[3,1,2]#
	}#
#
###	Check guesses for positive-definiteness. #
	for(istr in 0:nstr){#
		icpo<-check(c,nvar,istr)#
		if(icpo>=0){#
			message("")			#
			message("Values for semivariogram are not positive-definite.")#
			message("Try remaking semivariogram with different specifications.")#
			#
		}	#
	}
	for(i in 1:nstr){#
		if(modtyp==1||modtyp==4){#
			amin=dataf[1,1,1,2]/3#
			if(a[i]<33)am[i]=1 else am[i]=2#
		}else#
		if(modtyp==2||modtyp==5){#
			amin=dataf[1,1,1,2]#
			if(a[i]<100)am[i]=1 else am[i]=2#
		}#
	}
	#
	if(modtyp==3){#
		amin=dataf[1,1,1,2]/(3-((a[2]-1)*1.26795))#
		if(a[1]<(100/(3-((a[2]-1)*1.26795))))am[1]=1 else am[1]=2#
		am[2]=0.05	#
	}
	for(is in 0:nstr){#
		for(ir in 1:nvar){#
			for(ic in ir:nvar){#
				if(ir==ic)#
					dm[is+1,ir,ic]=covar[ir,ic]*0.25 #
				else#
					dm[is+1,ir,ic]=0.25*(sqrt(covar[ir,ir])*sqrt(covar[ic,ic]))#
			}#
		}#
	}
	if(ics==0)cpar=cparf#
#
	alp=0.975#
	nmarkov=60#
	istop=50#
	iwopt=wgt
ics=0
	if(ics==0)cpar=cparf#
#
	alp=0.975#
	nmarkov=60#
	istop=50#
	iwopt=wgt
wgt=1
	if(ics==0)cpar=cparf#
#
	alp=0.975#
	nmarkov=60#
	istop=50#
	iwopt=wgt
nlags
modtyp
dataf
sd
nvar
sd
a
c
iwopt
gammah<-function(x1,y1,x2,y2,modtyp,co,grad,c1,a1,c2,a2,sill){#
	x1mx2=x1=x2#
	y1my2=y1-y2#
	h=sqrt(x1mx2^2+y1my2^2)#
	alpha=1.75#
	#
	switch(modtyp,#
		iso.lin=return(co+grad*h),#
		iso.cir=#
		if(h>a1)#
			return(sill)#
		else{#
			hovera=h/a1#
			angle=atan(sqrt(1-hovera^2)/(hovera+0.000001))#
			h4=twoopi*hovera*sqrt(1-hovera^2)#
			return(co+c1*(twoopi*angle+h4))#
		},#
		#
		iso.sph=#
		if(h>a1)#
			return(sill)#
		else{#
			hovera=h/a1#
			return(co+c1*(1.5*hovera-0.5*hovera^3))#
		},#
		iso.exp=return(co+c1*(1-exp(-h/a1))),#
		#
		iso.pen=if(h>a1)#
			return(sill)#
		else#
			return(co+c1*(1.875*(h/a1)-1.25*(h/a1)^3+0.375*(h/a1)^5)),#
		#
		iso.dou=if(h>a2)#
			return(sill)#
		else#
			if(h>a1)#
				return(co+c1+c2*(1.5*(h/a2)-0.5*(h/a2)^3))#
			else#
				return(co+c1*(1.5*(h/a1)-0.5*(h/a1)^3)+c2*(1.5*(h/a2)-0.5*(h/a2)^3)),#
#
		dou.exp=return(co+c1(1-exp((-h/a1)))+c2*(1-exp((-h/a2)))),#
		#
		stable=return(co+c1*(1-exp(-h^alpha/a1^alpha))),#
		#
		dou.sta=return(co+c1*(1-exp(-h^alpha/a1^alpha))+c2*(1-exp(-h/a2))),#
		#
		bro=return(co+grad*h^a1)#
	)#
}
fcn<-function(modtyp,nlags,dataf,sd,nvar,a,c,iwopt){#
#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			if(ir==1&&ic==1)nlg=nlags[1] else#
			if(ir==1&&ic==2)nlg=nlags[2] else#
			if(ir==2&&ic==2)nlg=nlags[3]#
			C0=c[1,ir,ic]#
			C1=c[1,ir,ic]#
			a1=a[1]#
			#
			if(nstr>=1){#
				c2=c[3,ir,ic]#
				a2=a[1]#
			}else{#
				c2=0.0#
				a2=0.0#
			}#
			for(lag in 1:nlg){#
				h=dataf[ir,ic,1,lag]#
				gam=dataf[ir,ic,2,lag]#
				rnp=dataf[ir,ic,3,lag]#
####	 TODO: NEED TO FIX UP THE NEXT FEW LINES.#
				prgam=gammah(h,modtyp,C0,C1,a1,C2,a2)#
#
###	Weighted sums-of-squares#
				if(ir==ic)wt=(sd[ir])^(-4.0) else wt=((sd[ir])^(-4.0))+((sd[ic])^(-4.0))#
				#
				wdevs=((gam-prgam)^2.0)*wt#
#
				if(iwopt==1) wdevs=wdevs else#
				if(iwopt==2) wdevs=wdevs*rnp else#
				if(iwopt==3) wdevs=wdevs*(rnp/(prgam^2.0)) else#
				if(iwopt==4) wdevs=wdevs*(rnp/(h^2.0))#
				#
				of=of+wdevs#
				}#
			}#
		}#
#
#
	return(of)#
}
metrop<-function(f,fo,c){#
	pracc=exp((fo-f)/c)#
###	Using the line below it returns a random number between 0 and 1 based on the N(0,1)#
	ran=rnorm(1);while(ran>1||ran<0){ran=rnorm(1)};ran#
	if(ran<=pracc)accrej=1.0 else accrej=-1.0#
	return(accrej)#
}
	f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
	message("")#
	message('Weighted sum-of-squares of guessed parameters is:',f)#
	message("")#
	results$WSSGuessedParameter=f#
	results$initialTemperature=cpar#
	results$coolinParameter=alp#
	reults$numberTrialMarkovChain=nmarkov#
	results$numberMarkovChainReturningNoChange=istop#
	results$weightingOption=iwopt
f
fcn<-function(modtyp,nlags,dataf,sd,nvar,a,c,iwopt){#
	of=0#
	rnpt=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			if(ir==1&&ic==1)nlg=nlags[1] else#
			if(ir==1&&ic==2)nlg=nlags[2] else#
			if(ir==2&&ic==2)nlg=nlags[3]#
			C0=c[1,ir,ic]#
			C1=c[1,ir,ic]#
			a1=a[1]#
			#
			if(nstr>=1){#
				c2=c[3,ir,ic]#
				a2=a[1]#
			}else{#
				c2=0.0#
				a2=0.0#
			}#
			for(lag in 1:nlg){#
				h=dataf[ir,ic,1,lag]#
				gam=dataf[ir,ic,2,lag]#
				rnp=dataf[ir,ic,3,lag]#
####	 TODO: NEED TO FIX UP THE NEXT FEW LINES.#
				prgam=gammah(h,modtyp,C0,C1,a1,C2,a2)#
#
###	Weighted sums-of-squares#
				if(ir==ic)wt=(sd[ir])^(-4.0) else wt=((sd[ir])^(-4.0))+((sd[ic])^(-4.0))#
				#
				wdevs=((gam-prgam)^2.0)*wt#
#
				if(iwopt==1) wdevs=wdevs else#
				if(iwopt==2) wdevs=wdevs*rnp else#
				if(iwopt==3) wdevs=wdevs*(rnp/(prgam^2.0)) else#
				if(iwopt==4) wdevs=wdevs*(rnp/(h^2.0))#
				#
				of=of+wdevs#
				}#
			}#
		}#
#
#
	return(of)#
}#
#
#######################################################################################################
################################### The metrop FUNCTION ###############################################
#######################################################################################################
metrop<-function(f,fo,c){#
	pracc=exp((fo-f)/c)#
###	Using the line below it returns a random number between 0 and 1 based on the N(0,1)#
	ran=rnorm(1);while(ran>1||ran<0){ran=rnorm(1)};ran#
	if(ran<=pracc)accrej=1.0 else accrej=-1.0#
	return(accrej)#
}
f
	f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
	message("")#
	message('Weighted sum-of-squares of guessed parameters is:',f)#
	message("")#
	results$WSSGuessedParameter=f#
	results$initialTemperature=cpar#
	results$coolinParameter=alp#
	reults$numberTrialMarkovChain=nmarkov#
	results$numberMarkovChainReturningNoChange=istop#
	results$weightingOption=iwopt
nlags
nlags=cbind(20,20,20)
nolags=nlags
	f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
	message("")#
	message('Weighted sum-of-squares of guessed parameters is:',f)#
	message("")#
	results$WSSGuessedParameter=f#
	results$initialTemperature=cpar#
	results$coolinParameter=alp#
	reults$numberTrialMarkovChain=nmarkov#
	results$numberMarkovChainReturningNoChange=istop#
	results$weightingOption=iwopt
f
cpar
cpar=2000
	f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
	message("")#
	message('Weighted sum-of-squares of guessed parameters is:',f)#
	message("")#
	results$WSSGuessedParameter=f#
	results$initialTemperature=cpar#
	results$coolinParameter=alp#
	reults$numberTrialMarkovChain=nmarkov#
	results$numberMarkovChainReturningNoChange=istop#
	results$weightingOption=iwopt
f
	f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
	message("")#
	message('Weighted sum-of-squares of guessed parameters is:',f)#
	message("")#
	results$WSSGuessedParameter=f#
	results$initialTemperature=cpar#
	results$coolinParameter=alp#
	results$numberTrialMarkovChain=nmarkov#
	results$numberMarkovChainReturningNoChange=istop#
	results$weightingOption=iwopt
fic=-10.0#
	nunch=0#
#
###	Iterate cooling s
for(ics in 1:2000){#
		if(nunch>=istop){#
			break#
			temp=1#
		}
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am(istr)#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
lock=0
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
f
fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am(istr)#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
#
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
for(ics in 1:2000){#
		print(i)#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
fic
nunch
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		print(ics)#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
temp
ics
results$other.ics
results$other.f
results$other.pacc
of=0#
	rnpt=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			if(ir==1&&ic==1)nlg=nlags[1] else#
			if(ir==1&&ic==2)nlg=nlags[2] else#
			if(ir==2&&ic==2)nlg=nlags[3]#
			C0=c[1,ir,ic]#
			C1=c[1,ir,ic]#
			a1=a[1]#
			#
			if(nstr>=1){#
				c2=c[3,ir,ic]#
				a2=a[1]#
			}else{#
				c2=0.0#
				a2=0.0#
			}
for(lag in 1:nlg){#
				h=dataf[ir,ic,1,lag]#
				gam=dataf[ir,ic,2,lag]#
				rnp=dataf[ir,ic,3,lag]#
####	 TODO: NEED TO FIX UP THE NEXT FEW LINES.#
				prgam=gammah(h,modtyp,C0,C1,a1,C2,a2)#
#
###	Weighted sums-of-squares#
				if(ir==ic)wt=(sd[ir])^(-4.0) else wt=((sd[ir])^(-4.0))+((sd[ic])^(-4.0))#
				#
				wdevs=((gam-prgam)^2.0)*wt#
#
				if(iwopt==1) wdevs=wdevs else#
				if(iwopt==2) wdevs=wdevs*rnp else#
				if(iwopt==3) wdevs=wdevs*(rnp/(prgam^2.0)) else#
				if(iwopt==4) wdevs=wdevs*(rnp/(h^2.0))#
				#
				of=of+wdevs#
				}#
			}#
		}
of
wdevs
gam
prgam
wt
gammah(h,4,C0,c1,a1,c2,a2)
c1
gammah(h,modtyp,co,c1,a1,c2,a2)
co
of=0#
	rnpt=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			if(ir==1&&ic==1)nlg=nlags[1] else#
			if(ir==1&&ic==2)nlg=nlags[2] else#
			if(ir==2&&ic==2)nlg=nlags[3]#
			co=c[1,ir,ic]#
			c1=c[1,ir,ic]#
			a1=a[1]#
			#
			if(nstr>=1){#
				c2=c[3,ir,ic]#
				a2=a[1]#
			}else{#
				c2=0.0#
				a2=0.0#
			}#
			for(lag in 1:nlg){#
				h=dataf[ir,ic,1,lag]#
				gam=dataf[ir,ic,2,lag]#
				rnp=dataf[ir,ic,3,lag]#
####	 TODO: NEED TO FIX UP THE NEXT FEW LINES.#
				prgam=gammah(h,modtyp,co,c1,a1,c2,a2)#
#
###	Weighted sums-of-squares#
				if(ir==ic)wt=(sd[ir])^(-4.0) else wt=((sd[ir])^(-4.0))+((sd[ic])^(-4.0))#
				#
				wdevs=((gam-prgam)^2.0)*wt#
#
				if(iwopt==1) wdevs=wdevs else#
				if(iwopt==2) wdevs=wdevs*rnp else#
				if(iwopt==3) wdevs=wdevs*(rnp/(prgam^2.0)) else#
				if(iwopt==4) wdevs=wdevs*(rnp/(h^2.0))#
				#
				of=of+wdevs#
				}#
			}#
		}
of
h
modtyp
co
c1
a1
c2
a2
gammah(h,modtyp,co,c1,a1,c2,a2)
dataf(ir,ic,1,lag)
dataf
dataf[]ir,ic,1,lag]
dataf[ir,ic,1,lag]
gammah<-function(h,modtyp,co,c1,a1,c2,a2){#
	alpha=1.75#
	sill=co+c1+c2#
#
	switch(modtyp,#
		iso.lin=return(co*h),#
		iso.cir=#
		if(h>a1)#
			return(sill)#
		else{#
			hovera=h/a1#
			angle=atan(sqrt(1-hovera^2)/(hovera+0.000001))#
			h4=twoopi*hovera*sqrt(1-hovera^2)#
			return(co+c1*(twoopi*angle+h4))#
		},#
		#
		iso.sph=#
		if(h>a1)#
			return(sill)#
		else{#
			hovera=h/a1#
			return(co+c1*(1.5*hovera-0.5*hovera^3))#
		},#
		iso.exp=return(co+c1*(1-exp(-h/a1))),#
		#
		iso.pen=if(h>a1)#
			return(sill)#
		else#
			return(co+c1*(1.875*(h/a1)-1.25*(h/a1)^3+0.375*(h/a1)^5)),#
		#
		iso.dou=if(h>a2)#
			return(sill)#
		else#
			if(h>a1)#
				return(co+c1+c2*(1.5*(h/a2)-0.5*(h/a2)^3))#
			else#
				return(co+c1*(1.5*(h/a1)-0.5*(h/a1)^3)+c2*(1.5*(h/a2)-0.5*(h/a2)^3)),#
#
		dou.exp=return(co+c1(1-exp((-h/a1)))+c2*(1-exp((-h/a2)))),#
		#
		stable=return(co+c1*(1-exp(-h^alpha/a1^alpha))),#
		#
		dou.sta=return(co+c1*(1-exp(-h^alpha/a1^alpha))+c2*(1-exp(-h/a2))),#
		#
		bro=return(co*h^a1)#
	)#
}
gammah(h,modtyp,co,c1,a1,c2,a2)
of=0#
	rnpt=0#
	for(ir in 1:nvar){#
		for(ic in ir:nvar){#
			if(ir==1&&ic==1)nlg=nlags[1] else#
			if(ir==1&&ic==2)nlg=nlags[2] else#
			if(ir==2&&ic==2)nlg=nlags[3]#
			co=c[1,ir,ic]#
			c1=c[1,ir,ic]#
			a1=a[1]#
			#
			if(nstr>=1){#
				c2=c[3,ir,ic]#
				a2=a[1]#
			}else{#
				c2=0.0#
				a2=0.0#
			}#
			for(lag in 1:nlg){#
				h=dataf[ir,ic,1,lag]#
				gam=dataf[ir,ic,2,lag]#
				rnp=dataf[ir,ic,3,lag]#
####	 TODO: NEED TO FIX UP THE NEXT FEW LINES.#
				prgam=gammah(h,modtyp,co,c1,a1,c2,a2)#
#
###	Weighted sums-of-squares#
				if(ir==ic)wt=(sd[ir])^(-4.0) else wt=((sd[ir])^(-4.0))+((sd[ic])^(-4.0))#
				#
				wdevs=((gam-prgam)^2.0)*wt#
#
				if(iwopt==1) wdevs=wdevs else#
				if(iwopt==2) wdevs=wdevs*rnp else#
				if(iwopt==3) wdevs=wdevs*(rnp/(prgam^2.0)) else#
				if(iwopt==4) wdevs=wdevs*(rnp/(h^2.0))#
				#
				of=of+wdevs#
				}#
			}#
		}
of
#
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		print(ics)#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		print(ics)#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
					#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{					#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				print(istr)#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						print("did the fcn")#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		print("Step one for the ",ics," time")#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
						print("Step two for the ",imc," time")#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{#
						print("in the repear section")#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				print(istr)#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						print("did the fcn")#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		print(ics)#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
						print("Step two for the ",imc," time")#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{#
						print("in the repear section")#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				print(istr)#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						print("did the fcn")#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
print("hello",7,"hello")
print("hello",7)
print("hello",j)
print("hello",j=7)
j
j=7
cat("hello",j)
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		cat("Step one for the ",ics," time")#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
						cat("Step two for the ",imc," time")#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{#
						print("in the repear section")#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				print(istr)#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						print("did the fcn")#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
###	has not been changed.#
#
	fic=-10.0#
	nunch=0#
#
###	Iterate cooling step.#
#
	for(ics in 1:2000){#
		cat("Step one for the ",ics," time")#
		if(nunch>=istop){#
			break#
			temp=1#
		}#
#####	NO BRACKETS ARE BROKEN ABOVE THIS LINE#
		rej=0#
		acc=0#
#
###		Iterate within the step.#
		for(imc in 1:nmarkov){#
						cat("Step two for the ",imc," time")#
###			Adjust each parameter in turn.#
#
###			Distance parameter(s) first.#
			if(lock==0){#
				for(istr in 1:nstr){#
					ao=a[istr]#
#
					repeat{#
						print("in the repear section")#
						r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
						rc=(r-0.5)*2.0*am[istr]#
#
###					Reject inappropriate values.#
						if(modtyp<4){#
							if(modtyp==3&&istr==2){#
								if((ao+rc)<=1||(ao+rc)>=2)next#
							}else{#
								if((ao+rc)<=amin||(ao+rc)>amax)next#
							}#
						}else{#
							if(modtyp==4||modtyp==5){#
								if(istr==1){#
									if((ao+rc)<=amin||(ao+rc)>=a[2])next#
								}else{#
									if((ao+rc)<=a[1]||(ao+rc)>amax)next#
								}#
							}else{#
								break#
							}#
						print("******************************")#
						print("******************************")#
						print("******************************")#
						}#
					}	#
#
					a[istr]=ao+rc#
					fo=f#
#
					f<-fcn(modtyp,nlags,dataf,sd,nstr,nvar,a,c,iwopt)#
					#
					if(f>fo){#
					#
						accrej<-metrop(f,fo,cpar,accrej)#
					#
						if(accrej<0){#
							rej=rej+1#
							a[istr]=ao#
							f=fo#
							break#
						}#
					}#
					if(accrej<0){break}#
					acc=acc+1	#
				}	#
#
			}#
#
#
###			Now adjust variances.#
			for(istr in 0:nstr){#
				print(istr)#
				if(modtyp==3&&istr==2)break			#
				for(ir in 1:nvar){#
					for(ic in ir:nvar){#
						cold=c[istr+1,ir,ic]#
						repeat{					#
							r=rnorm(1);while(r>1||r<0){r=rnorm(1)}#
							rc=(r-0.5)*2.0*dm[istr+1,ir,ic]#
#
###						Reject inappropriate values.#
							if(ir==ic){#
								if((cold+rc)<0)next#
							}else{#
								if(icvp==1&&(cold+rc)<0)next#
									else#
								if(icvp==-1&&(cold+rc)>0)next#
							}#
						#
						#
#
###						Zero value if less than tolerance.#
							if(abs(cold+rc)>=abs(covar[ir,ic]/1000)) c[istr+1,ir,ic]=cold+rc else c[istr+1,ir,ic]=0#
							c[istr+1,ic,ir]=c[istr+1,ir,ic]#
#
#
###						Check for positive-definiteness.#
							icpo<-check(c,nvar,istr)#
							if(icpo<0){#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr,ir,ic]#
								next#
							}#
						}#
#
						if(lock==1)fo=f#
#
						f<-fcn(modtyp,nlags,dataf,sd,nvar,a,c,iwopt)#
						print("did the fcn")#
						for(i in 1:2){						#
							if(f<=fo)break#
#
#
							accrej<-metrop(f,fo,cpar)#
						#
							if(accrej<0){#
								rej=rej+1#
								c[istr+1,ir,ic]=cold#
								c[istr+1,ic,ir]=c[istr+1,ir,ic]#
								f=fo#
								temp=2#
								break#
							}#
						}#
						if(temp==2)break					#
						acc=acc+1#
#
					}#
				}#
			}			#
#
			pacc=acc/(acc+rej)#
#
			if(ics==1)paccin=pacc#
		}#
		for(i in 1:2){#
			if(temp==1)break#
			if(fic==f){#
				nunch=nunch+1 #
			}else{#
				nunch=0#
				fic=f#
			}#
#
			if(ics==1){#
				message(' ')#
				message('Proportion of changes accepted in 1st chain: ',paccin)#
				message(' ')#
				message('(Between 0.90-0.99 is optimal. If equal to one, reject')#
				message('and decrease the initial temperature. If less than 0.9,')#
				message('reject and increase the initial temperature).')#
				iconto<-as.numeric(readline('To accept press 0, to exit press 1:'))#
				if(iconto==0){#
					message("")#
					message("Minimising weighted sum-of-squares")#
					message("(please be patient)...")#
					message("")#
				}else{#
					if(iconto==1)stop(options("show.error.messages"=FALSE))#
				}#
			}#
		}#
#
		#
		cpar=cpar*alp#
#
###		Parameter 'ics' is the Markov chain number, 'f' is the criterion minimised#
###		and 'pacc' is how much it has changed since the last time.#
		results$other.ics=ics#
		results$other.f=f#
		results$other.pacc=pacc#
#
	}
fff
f
f
f
f
f
f
f
f
f
f
f
f
f
